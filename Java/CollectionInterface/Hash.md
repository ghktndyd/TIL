# Hash

## 1. Hash란?

- 어떤 데이터를 **특정한 숫자값(해시값)**으로 변환하는 것
- 여기서 해시값은 객체의 주소 값은 아니지만 주소 값처럼 사용됨
- 그리고 변환하는 과정에서 쓰는 게 **해시 함수**

---

## 2. Hash의 특징

- 해시는 입력이 같다면 출력도 같아야 한다.
- 입력이 다르면 대부분 출력도 다르다. 이 말은 입력이 달라도 같은 출력이 나올 수도 있다는 뜻이다.
- 계산이 빠르다.
- 해시값은 최대한 균등하게 분포해야 충돌이 적다.

### 2-1. Java의 hashCode()

- 해시함수는 해시를 해주는 함수다.
- 자바의 `hashCode()`는 해시함수다.
- 모든 객체는 `hashCode()`라는 메서드를 가지고 있다.
- HashMap, HashSet 등 Hash가 붙은 컬렉션에서 객체의 저장 위치를 결정하는 데에 사용한다.

### 2-2. hashCode()와 equals()의 관계

- `equals()`
    - 두 객체가 논리적으로 동등한지를 비교하는 메서드
    - 예를 들어서 "주민번호가 같은 사람은 같은 사람으로 취급" 하는 것 처럼


- `hashCode()`
    - 객체의 해시코드를 반환하는 메서드
    - HashMap/HashSet 같은 해시 기반 컬렉션에서 객체를 저장할 위치를 결정할 때 사용


- > `equals()`가 `true`인 두 객체의 해시코드는 같아야 한다.
- 위 말은 즉 논리적으로 같은 객체라면 해시값도 같아야 한다는 뜻임
- 동등성을 맞춰주기 때문에 `equals()`를 오버라이딩하면 `hashCode()`도 오버라이딩해야 한다.


- > 하지만 `hashCode()`가 같다고 해서 `equals()`가 `true`인 것은 아니다.
- 위 말은 해시값이 같더라도 객체가 논리적으로 다를 수도 있다는 뜻임
- 이런 상황을 **해시 충돌**이라고 한다

### 2-3. 버킷

- 해시 값을 기반으로 나눠지는 데이터 저장 공간
- 같은 버킷에 저장되었다는 것은 해시 값이 같다는 것이고 이게 **해시충돌**이다.
- 자바8부터는 충돌이 많으면 내부 구조를 Red-Black Tree로 바꾼다.
- 그렇기 때문에 HashMap이 배열과 LinkedList로 구현되어 있다고 답변하면 안 된다.

---

## 3. 결론은

- 객체를 정의할 때 equals와 hashCode를 같이 오버라이딩하자
- 논리적 동등성의 기준이 존재한다면 equals()에서 그 기준을 구현하고,
- hashCode()애서도 **같은 필드**로 해시값을 만들어야 한다.
- 예를 들어서 주소 객체의 우편번호, 주소, 상세주소가 동일하다면 같은 주소 객체라고 판단할 수 있도록 해야 한다.
- 이때 기준은 우편번호, 주소, 상세주소 필드가 되는 것이다.

---

## 자바에서 Hash 기반 클래스

- `HashMap`: 가장 기본적인 비동기 Map 구현체고, 동기화가 되지 않는다.
- `HashTable`: 오래된 동기화 Map 구현체인데 메서드 전체가 synchronized로 동기화되어 있어서 성능이 좋지 않다.
- `LinkedHashMap`: 순서를 유지하는 HashMap 구현체
- `ConcurrentHashMap`: 동기화된 HashMap 구현체고, 버킷 단위 락과 CAS를 사용해서 성능이 좋다.

