# 컨텍스트 스위치

- CPU가 현재 실행 중인 프로세스의 상태를 저장하고, 다음에 실행할 프로세서의 상태를 복원하는 과정
- 현재 하던 작업은 -> 메모리에 저장
- 다음에 할 작업은 -> CPU에 로드

---

# 컨텍스트가 뭔데

- 컨텍스트는 **CPU가 현재 실행중인 작업의 모든 상태 정보**
- 저장할 정보는 OS나 CPU 아키텍처마다 다름

## 일반적으로 저장하는 컨텍스트

### 레지스터 상태

- Program Counter: 다음에 실행할 명령어의 주소
- Stack Pointer: 현재 스택 위치
- General-purpose Registers: 계산 중인 값, 함수 인자 등등
- Status Register / Flags: 조건 플래그
- Floating Point Registers: 부동소수점 연산 상태
- SIMD 레지스터: 벡터 연산 상태

### 메모리 관련 상태

- MMU 관련 정보
- 세그먼트 레지스터
- TLB 캐시 상태 (일반적으론 flush 필요)

### OS 관리 정보

- **프로세스 제어 블럭(PCB)에 저장되는 데이터**
- 프로세스 ID
- 스케줄링 우선순위
- CPU 사용 시간
- I/O 대기 상태 등

---

# 컨텍스트 스위치가 발생할 때

- 타임 슬라이스 종료 (강제로 회수)
    - 시분할 스케줄링에서 CPU 할당 시간이 끝남


- I/O 요청 (자발적 반납)
    - 디스크/네트워크 작업 요청 후에 CPU 반환


- 시스템 콜 (자발적 반납)
    - `read()`, `write()` 같은 커널 모드에 진입


- 인터럽트 (강제로 회수)
    - 키보드 입력 등


- 우선순위 높은 프로세스 도착 (강제로 회수)
    - 실시간 프로세스가 ready 상태로 전환됨

---

# 컨텍스트 스위치 과정

### 1. 현재 작업 상태 저장

- 인터럽트 혹은 시스템콜 발생
- CPU -> 커널 모드 전환
- 현재 프로세스의 **레지스터 값을 커널 스택이나 PCB에 저장**
- 필요하면 TLB flush

### 2. 스케줄러 실행

- 스케줄러가 다음 실행할 프로세스 선택
- PCB에서 우선순위, 상태 등등 확인

### 3. 다음 작업 복원

- 선택된 프로세스의 PCB에서 레지스터 값 읽기
- CPU 레지스터에 값을 복원
- Program Counter를 해당 프로세스의 명령어 위치로 설정함
- 커널 모드 -> 사용자 모드 전환
- 명령어 실행 재개

---

# 컨텍스트 스위치와 스레드

- 프로세스 간 컨텍스트 스위치
    - CPU 레지스터 + 메모리 주소 공간 변경 + TLB flush가 필요함

- 스레드 간 컨텍스트 스위치 (동일한 프로세스)
    - 주소공간 변경 필요 X

> 자바에서 `Thread` 전환은 OS 스레드 기반이므로 커널 레벨 스레드 스위치가 발생

---

# 스레드 컨텍스트 스위칭

- 스레드에는 TCB(Thread Control Block)라는 구조체가 있다.
- TCB에는 스레드의 상태, 레지스터 값, 스택 포인터, PCB를 참조하는 포인터 등이 있다.
- 스레드가 하나 생성될 때 PCB 내에 생성되며 컨텍스트 스위치가 발생하면 기존 스레드 의 TCB를 저장하고, 다음 스레드의 TCB를 복원한다.
- 이 과정은 프로세스 간 컨텍스트 스위치보다 빠르다.

## 프로세스 간 컨텍스트 스위치 vs 스레드 간 컨텍스트 스위치

- 프로세스는 컨텍스트 스위칭할 때 메로리 주소 공간을 위한 여러가지 작업을 해야 돼서 오버헤드가 크다.
- 스레드는 프로세스 내에 메모리를 공유하기 때문에 메모리 주소 관련 추가 작업이 필요 없어서 오버헤드가 작다.
- 그래서 스레드 간 컨텍스트 스위치는 프로세스 간 컨텍스트 스위치보다 훨씬 빠르다.
- 근데 그렇다고 해서 스레드를 많이 생성하면 메모리 저하 현상이 발생하거나 빈번하게 컨텍스트 스위치가 발생할 수 있으니까 주의하자!