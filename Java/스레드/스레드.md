- Java에서 쓰레드를 생성하는 방법 중 하나는 Thread 클래스를 `extends` 키워드로 상속받는 방법이 있다.

```java
public class HelloThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + ": run()");
    }
}
```

- `Thread` 클래스를 상속받고, 스레드가 수행할 작업은 `run()` 메서드에 오버라이딩해서 작성한다.
- `Thread.currentThread().getName()`은 현재 실행 중인 스레드 이름을 가져온다.
- 따로 지정 안하면 `main (JVM 기동시에 처음 생성되는 기본 스레드)`, `Thread-0`, `Thread-1` 이런 식으로 자동 생성된다.

```java
public class HelloThreadMain {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + ": main() start");

        HelloThread helloThread = new HelloThread();
        System.out.println(Thread.currentThread().getName() + " start() 호출 전");
        helloThread.start();
        System.out.println(Thread.currentThread().getName() + " start() 호출 후");

        System.out.println(Thread.currentThread().getName() + ": main() end");
    }
}
```

- 위 코드 흐름은 아래와 같다.

    1. `main` 스레드가 시작된다. 이때 `"main: main() start"` 문자열이 출력된다.
    2. `"main start() 호출 전"`이 출력된다.
    3. `helloThread.start()`가 호출된다. **(매우중요) 새로운 스레드 생성하고 `run()` 메서드를 실행 예약한다.**
    4. 위 호출을 하고 메인 스레드는 자기 일을 계속 한다. `main start() 호출 후` 문자열 출력된다.
    5. 스케줄러가 결정한 시점에 `HelloThread.run()`이 실행된다. `"Thread-0: run()"` 문자열 출력된다.
    6. `"main: main() end"` 문자열 출력 (하지만 이 시점이 나올 때까지 `Thread-0`이 아직 실행되고 있을 수도 있다.

---

## 꼭 알아야 하는 것

#### 스레드의 순서는 보장되지 않는다.

```text
main: main() start
main start() 호출 전
main start() 호출 후
main: main() end
Thread-0: run()
```

또는

```text
main: main() start
main start() 호출 전
Thread-0: run()
main start() 호출 후
main: main() end
```

- 스레드의 실행 순서는 보장되지 않는다.
- → JVM이 스레드를 생성하고, OS 스케줄러가 실행 시점을 결정한다.
- 때문에 멀티스레드 환경이라면 동기화 없이 실행 순서를 절대로 가정하고 구현하면 안된다.

---

#### `start()` vs `run()`

- `start()`
    - 새로운 스레드를 생성하고, 생성한 스레드가 내부적으로 `run()` 울 호ㅗ출한다.

- `run()`
    - 직접 호출하면 단순한 메서드 콜이다. 새 스레드가 생성되지 않고, **메인스레드에서 실행된다**


