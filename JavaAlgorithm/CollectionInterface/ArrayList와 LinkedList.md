# ArrayList와 LinkedList

## 1. 내부 구조

### ArrayList

- 비유하자면 도서관 책꽂이와 유사함
- 책꽂이에는 각 칸마다 번호가 있는데, 모든 책은 번호에 맞게 정렬돼서 꽂혀 있음
- 만약에서 여기서 13번째 책을 찾으려면 그냥 13번 칸에 가서 책을 꺼내면 됨
- 하지만 중간에 책을 넣으려면 13번의 뒷 책들을 다 한 칸씩 밀어줘야 함

- 내부 구조:
    - 배열(Array)이 기반
    - `Object[]` 타입의 배열이 내부에 있음


- 특징:
    - 요소들은 배열의 연속된 공간에 저장됨
    - 인덱스를 통해서 빠르게 접근할 수 있음 (`list.get(index)` -> 바로 메모리 주소를 계산함)
    - 크기를 초과하면 내부적으로 더 큰 배열을 만들어서 복사하는 방식

### LinkedList

- 비유하자면 기차와 유사함
- 기차는 여러 개의 칸으로 구성되어 있고, 각 칸은 이전/다음 칸의 참조를 가지고 있음
- 만약에 여기서 13번째 칸을 찾으려면 1번 칸부터 13번 칸까지 순서대로 찾아가야 함
- 중간에 열차를 한 칸 추가하려면 그냥 한 칸을 추가하고, 참조만 바꿔주면 됨


- 내부 구조:
    - 자바에서는 이중 연결 리스트(`Double Linked List`)로 구현되어 있음
    - 각 요소를 노드라고 하는데 이 노드는 자신과 이전/다음 노드의 참조를 가짐

- 특징:
    - 각 노드는 객체로 저장됨
    - 각 노드는 데이터, 이전/다음 노드의 참조를 가짐
    - 메모리상 공간이 연속되지 않아도 됨
    - 삽입/삭제 시에 노드간 연결을 이어주거나 끊으면 돼서 수행 속도가 빠름
    - 검색은 맨 앞이나 맨 뒤부터 순차적으로 노드를 찾아야 해서 수행 속도가 느림

---

## 2. 성능

| 연산                | ArrayList    | LinkedList |
|-------------------|--------------|------------|
| get(i)            | **O(1)**     | **O(N)**   |
| add(맨뒤)           | O(1) 또는 O(N) | O(1)       |
| add(i)            | **O(N)**     | **O(N)**   |
| remove(i)         | **O(N)**     | **O(N)**   |
| iterator.remove() | O(N)         | O(1)       |

- `get(i)`
    - ArrayList는 내부 구조가 배열이라서 i번째에 바로 접근 가능 → O(1)
    - LinkedList는 노드를 순차적으로 따라가면서 접근 → O(N)


- `add(맨뒤)`
    - ArrayList는 맨 뒤에 추가하는 경우 그냥 배열의 끝에 추가 → O(1)
    - 대신 ArrayList는 크기를 초과하면 내부적으로 배열 요소를 복사해서 크기를 늘림 → O(N)
    - LinkedList는 맨 뒤에 추가하는 경우 그냥 마지막 노드의 참조만 바꿔주면 됨 → O(1)
    - 대신 LinkedList는 맨 뒤에 추가하는 경우 마지막 노드를 찾아야 함 → O(N)


- `add(i), remove(i)`
    - ArrayList는 i번째에 추가하는 경우 i번째 이후의 모든 요소를 한 칸씩 뒤로 밀어야 함 → O(N)
    - LinkedList는 i번째에 추가하는 경우 i번째 노드의 이전/다음 노드의 참조만 바꿔주면 됨 → O(N)


- `remove(Iterator로 순회 중 삭제)`
    - ArrayList는 내부에서 Shift 연산이 발생 → O(N)
    - LinkedList는 노드의 이전/다음 노드의 참조만 바꿔주면 됨 → O(1)

---

## 3. 실제로 어떤 경우에 뭘 사용해야 할까?

### ArrayList가 적합한 경우

- 조회가 자주 발생하는 경우
    - 예) 리스트에서 20만 번째 요소를 빠르게 읽어야 할 때

- 요소 추가/삭제가 맨 뒤에서만 발생하는 경우
    - 예) Stack처럼 push나 pop만 사용

### LinkedList가 적합한 경우

- 요소를 추가/삭제하는 위치가 중간인 경우가 빈번할 때
    - 예) 리스트의 앞이나 중간에 자주 add/remove

- Iterator를 사용하여 요소를 삭제하는 경우가 빈번할 때
    - 예) LinkedList는 O(1), ArrayList는 O(N)

### 결론

- **웬만해서는 ArrayList를 사용하는 게 좋음**
- LinkedList는 정말 필요한 경우에만 사용하는 게 좋음
- 실무에서는 순차적으로 데이터를 추가하고, 필요하면 빠르게 인덱스 접근을 해야 하는 경우가 많음
- 그리고 배열 기반이기 때문에 메모리 접근이 연속적이고, CPU의 캐시 히트율이 높아서 성능이 좋음
- 크기가 정해져있을 경우에는 배열이 더 나을 수도 있긴 하다.
- 