# 리플렉션

- JVM의 클래스로더를 통해서 읽어온 클래스 정보를 사용하는 기술
- 런타임에 클래스의 구조(메서드, 필드, 생성자 등)를 분석하고, 조작할 수 있게 해주는 자바의 기능
- 즉 **정적인 코드를 분석하는 것이 아닌, 실행 중인 클래스를 조작하기 위한 기술**

# 리플렉션을 왜 쓰는가?

- 스프링 프레임워크, JPA 하이버네이트
    - 위와 같은 프레임워크나 라이브러리에서는 클래스 이름을 몰라도 메서드를 실행하거나 객체를 생성할 수 있어야 한다.
    - 어떤 클래스의 생성자를 실행하거나 private 필드를 주입할 때도 사용한다.
- Lombok
    - 어노테이션이 붙어있는지를 리플렉션으로 확인해서 어노테이션에 걸맞는 코드를 자동으로 클래스에 추가해주는 방식

# JVM에서의 리플렉션 동작

- 우선 자바의 대략적인 실행 구조를 알아보자
```scss
1. .java 파일을 개발자가 작성

2. 자바 컴파일러(javac)가 .java ➡️ .class (바이트코드)로 컴파일

3. 클래스 로딩 (ClassLoader)
  - .class 파일을 JVM이 읽어서 메모리에 로드
  - Metaspace 영역에 클래스 메타 정보를 저장

4. 클래스 링크 및 초기화
  - 검증 ➡️ 준비 ➡️ 해석

5. 실행 (JVM Execution)
  - 바이트코드를 인터프리터 또는 JIT 컴팡일러가 실행
```

- 리플렉션은 위 도식에서 `3. 클래스 로딩` 과정에서 시작되고, `4. 클래스 링크 및 초기화` 과정이 끝난 시점부터 리플렉션이 사용 가능하다.
- 상세하게 보자면
  - 클래스가 로드되면 메타스페이스 영역에 Class 객체가 생긴다.
  - 해당 객체를 통해서 메타 정보에 접근할 수 있게 된다면 그때부터 리플렉션 API들을 사용 가능해진다.

# 리플렉션이 동작하는 깊은 원리

## invoke 메서드

1. `Method.invoke()`는 JVM 내부에서 해당 클래스의 메서드 디스크립터를 가져온다.
2. 그리고 그걸 바탕으로 해당 메서드의 주소를 찾는다.
3. 매개변수를 스택에 푸시하고, 호출한다
4. 결과를 스택에서 꺼낸다.

- 그냥 한마디로 리플렉션은 JVM 내부적으로 메서드 주소를 찾아서 직접 실행하는 원리다.

## 스프링에서 리플렉션 쓰는 예시

```java
@Autowired
private UserRepository userRepository;
```

- 스프링은 클래스 스캔시에 `@Autowired` 필드를 찾는다.
- 이때 리플렉션의 `Field.setAccessible(true)`를 설정하여 private 필드도 접근이 가능하도록 한다.
- 찾으면 DI 컨테이너에서 알맞는 Bean을 찾아서 `field.set(instance, beanInstance)`로 주입한다.
- 위 과정은 리플렉션이 없다면 불가능하다
